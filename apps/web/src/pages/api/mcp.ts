import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { createAgelumMcpServer } from '@/lib/mcp';
import { getAgelumConfig } from '@/lib/config';
import type { NextApiRequest, NextApiResponse } from 'next';

// Store transports in a global map to persist across requests in dev mode.
// In a real production serverless environment, this wouldn't work (you'd need Redis/DB),
// but for "pnpm dev" and long-running Node servers, this is fine.
// We use globalThis to survive HMR (Hot Module Replacement) in development.

const globalForMcp = globalThis as unknown as {
  mcpTransports: Map<string, SSEServerTransport>;
};

if (!globalForMcp.mcpTransports) {
  globalForMcp.mcpTransports = new Map();
}

const transports = globalForMcp.mcpTransports;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    // 1. Establish SSE Connection
    const config = getAgelumConfig();
    const globalRoot = config?.rootGitDirectory;

    const server = createAgelumMcpServer(globalRoot);
    
    // The SDK's SSEServerTransport writes the initial headers and keeps the connection open.
    // We pass the endpoint path that clients should POST to.
    const transport = new SSEServerTransport('/api/mcp', res);
    
    // Connect server <-> transport
    await server.connect(transport);

    // Store the transport so we can route POST messages to it
    // The transport.sessionId is generated by the SDK
    transports.set(transport.sessionId, transport);

    // Clean up when the connection closes
    res.on('close', () => {
      console.log(`MCP session closed: ${transport.sessionId}`);
      transports.delete(transport.sessionId);
      server.close();
    });

    console.log(`MCP session started: ${transport.sessionId}`);
    return;
  }

  if (req.method === 'POST') {
    // 2. Handle Client Messages
    const { sessionId } = req.query;

    if (!sessionId || typeof sessionId !== 'string') {
      res.status(400).send('Missing sessionId');
      return;
    }

    const transport = transports.get(sessionId);
    if (!transport) {
      res.status(404).send('Session not found');
      return;
    }

    // The SDK handles parsing the body and dispatching it
    await transport.handlePostMessage(req, res);
    return;
  }

  res.status(405).send('Method Not Allowed');
}
